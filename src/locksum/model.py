from __future__ import annotations

import base64
import hashlib
import os

from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

# Key derivation
from . import config
from .config import file_exists
from .services import IntegrityChecker, KeyManager, VaultStore


class CryptoModel:
    """
    Handles all cryptographic operations and data persistence logic.
    This class encapsulates password hashing, key derivation, encryption,
    decryption, and secure data storage.
    """

    def __init__(self) -> None:
        # New modular services
        self.keys = KeyManager()
        self.integrity = IntegrityChecker()
        self.vault = VaultStore(self.keys, self.integrity)
        self._current_kdf: str = config.KDF_DEFAULT  # tracks algorithm used for header

    @property
    def hmac_key(self) -> bytes:  # noqa: D401
        return self.integrity.hmac_key

    # ------------------------------------------------------------------
    # Convenience proxies
    # ------------------------------------------------------------------

    @property
    def pass_hasher(self):  # noqa: D401
        """Expose the underlying Argon2 hasher for tests that patch policy."""
        return self.keys.pass_hasher

    @pass_hasher.setter
    def pass_hasher(self, value):  # noqa: D401
        # Replace the underlying hasher instance used by :pymeth:`verify_passcode`.
        self.keys._pass_hasher = value  # pylint: disable=protected-access

    @property
    def fernet(self) -> Fernet:
        return self.keys.fernet

    def _load_or_create_key(self, path: str, num_bytes: int) -> bytes:
        """Loads a key from the given path or creates a new one."""
        if file_exists(path):
            with open(path, "rb") as f:
                return f.read()
        key = os.urandom(num_bytes)
        with open(path, "wb") as f:
            f.write(key)
        return key

    def get_salt(self) -> bytes:
        """Loads or creates the salt for key derivation."""
        return self._load_or_create_key(config.DEFAULT_SALT_FILE, config.SALT_BYTES)

    def derive_fernet_key(
        self, passcode: str, salt: bytes, *, algorithm: str | None = None
    ):  # noqa: D401, E501
        """Derive both encryption *and* integrity keys in a single step."""
        self.keys.derive_fernet_key(passcode, salt, algorithm=algorithm)
        # Inject the freshly derived integrity key **only** if one has not been
        # set already.  This preserves backwards-compatibility with legacy
        # behaviour relied upon by the test-suite where the HMAC key remains
        # constant even if the user re-derives a new encryption key during the
        # same runtime session.
        if getattr(self.integrity, "_hmac_key", None) is None:
            self.integrity.set_key(self.keys.hmac_key)
        # Persist the algorithm choice for header generation.  Fall back to the
        # key-manager's current setting if *algorithm* is ``None``.
        self._current_kdf = (
            algorithm or self.keys._current_kdf
        )  # pylint: disable=protected-access

    def hash_new_passcode(self, passcode: str) -> None:
        """Hashes a new passcode with Argon2 and stores it."""
        pass_hash_str = self.keys.pass_hasher.hash(passcode)
        with open(config.PASS_HASH_FILE, "w") as f:
            f.write(pass_hash_str)

    def verify_passcode(self, passcode: str) -> bool:  # noqa: D401
        return self.keys.verify_passcode(passcode)

    def check_passcode_strength(self, passcode: str) -> dict:  # noqa: D401
        return self.keys.check_passcode_strength(passcode)

    def sha256_hash(self, text: str) -> str:
        """Returns the hexadecimal SHA-256 digest of text."""
        # ``surrogatepass`` allows encoding of lone surrogates generated by
        # property-based tests without crashing.
        return hashlib.sha256(text.encode("utf-8", "surrogatepass")).hexdigest()

    def load_encrypted_data(self):
        return self.vault.load()

    def save_encrypted_data(self, data: list[tuple[str, str]]) -> None:
        """Encrypts and persists data to disk with an integrity check."""
        if not self.keys.fernet:
            raise RuntimeError("Fernet key not initialized. Cannot encrypt data.")

        def _encode(txt: str) -> str:
            raw = txt.encode("utf-8", "surrogatepass")
            return base64.urlsafe_b64encode(raw).decode("ascii")

        data_str = "\n".join(
            [
                f"{_encode(text)}{config.DATA_SEPARATOR}{hash_val}"
                for text, hash_val in data
            ]  # noqa: E501
        )

        alg_code = (
            config.ALG_CODE_PBKDF2
            if self._current_kdf == "pbkdf2"
            else config.ALG_CODE_SCRYPT
        )

        use_lsv2 = os.getenv(config.VAULT_VERSION_ENV, "LSV1").upper() == "LSV2"

        if use_lsv2:
            # --- AES-GCM path (LSV2) ---
            nonce = os.urandom(config.AES_GCM_NONCE_BYTES)
            aesgcm = AESGCM(self.keys.sym_key)
            ciphertext = aesgcm.encrypt(
                nonce,
                data_str.encode("utf-8", "surrogatepass"),
                None,
            )  # noqa: E501

            header = config.FILE_MAGIC_V2 + bytes([alg_code]) + nonce

            with open(config.ENCRYPTED_DATA_FILE, "wb") as f:
                f.write(header + ciphertext)
        else:
            # --- Fernet + HMAC path (LSV1) ---
            encrypted_data = self.keys.fernet.encrypt(
                data_str.encode("utf-8", "surrogatepass")
            )  # noqa: E501

            header = config.FILE_MAGIC + bytes([alg_code])
            integrity_hmac = self._compute_hmac(header + encrypted_data)

            with open(config.ENCRYPTED_DATA_FILE, "wb") as f:
                f.write(header + encrypted_data + integrity_hmac)

    def _compute_hmac(self, data: bytes) -> bytes:  # noqa: D401
        return self.integrity.compute(data)

    def _verify_hmac(self, data: bytes, provided_hmac: bytes) -> bool:
        """Verifies that the HMAC-SHA256 matches the expected value."""
        return self.integrity.verify(data, provided_hmac)

    def wipe_all_data(self):
        self.vault.wipe()
        self.keys.wipe()
        self.integrity.wipe()

    # ------------------------------------------------------------------
    # Runtime secret purging (GUI logout etc.)
    # ------------------------------------------------------------------

    def clear_runtime_secrets(self) -> None:  # noqa: D401
        """Remove encryption & integrity keys from memory without touching disk."""
        self.keys.clear_runtime_keys()
        self.integrity.wipe()

    # ------------------------------------------------------------------
    # Vault header helpers
    # ------------------------------------------------------------------
    def detect_kdf_algorithm(self) -> str:  # noqa: D401
        """Return the KDF algorithm encoded in the vault header.

        If the encrypted data file is absent or the header is from an old
        version that lacks the algorithm byte, the project-wide default is
        returned. This lets callers derive the correct key *before* they have
        decrypted the ciphertext.
        """
        path = config.ENCRYPTED_DATA_FILE
        if not file_exists(path):
            return config.KDF_DEFAULT

        try:
            with open(path, "rb") as f:
                magic = f.read(len(config.FILE_MAGIC))
                if magic != config.FILE_MAGIC:
                    # Legacy vault without any header – assume default
                    return config.KDF_DEFAULT
                alg_byte = f.read(1)
                if len(alg_byte) == 0:
                    return config.KDF_DEFAULT  # v1 header without alg byte

                if alg_byte[0] == config.ALG_CODE_PBKDF2:
                    return "pbkdf2"
                if alg_byte[0] == config.ALG_CODE_SCRYPT:
                    return "scrypt"
        except OSError:  # pragma: no cover – permissions or similar edge cases
            pass

        # Fallback for unexpected conditions / unknown byte
        return config.KDF_DEFAULT
